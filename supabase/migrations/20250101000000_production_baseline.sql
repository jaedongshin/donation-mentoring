-- ============================================
-- PRODUCTION BASELINE MIGRATION
-- ============================================
-- This migration represents the exact state of production database
-- as of January 2026. All subsequent migrations build from here.
--
-- DO NOT MODIFY THIS FILE - it's a snapshot of production state.
-- ============================================

-- ============================================
-- TABLES
-- ============================================

-- Admins table (legacy)
CREATE TABLE IF NOT EXISTS public.admins (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    email text NOT NULL,
    password text,
    reset_token text,
    reset_token_expires timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT admins_pkey PRIMARY KEY (id),
    CONSTRAINT admins_email_key UNIQUE (email)
);

-- App config table
CREATE TABLE IF NOT EXISTS public.app_config (
    key text NOT NULL,
    value text NOT NULL,
    CONSTRAINT app_config_pkey PRIMARY KEY (key)
);

-- Mentors table
CREATE TABLE IF NOT EXISTS public.mentors (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name_en character varying(255) NOT NULL,
    location_en character varying(255) NOT NULL,
    description_en text NOT NULL,
    name_ko character varying(255) NOT NULL,
    location_ko character varying(255) NOT NULL,
    description_ko text NOT NULL,
    picture_url text,
    tags jsonb DEFAULT '[]'::jsonb,
    display_order integer DEFAULT 0,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    position_en text,
    position_ko text,
    linkedin_url text,
    calendly_url text,
    company_en text,
    company_ko text,
    email text,
    languages text[],
    session_time_minutes integer,
    session_price_usd numeric(10,2),
    CONSTRAINT mentors_pkey PRIMARY KEY (id)
);

-- Profiles table (auth)
CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid NOT NULL,
    email text,
    display_name text,
    avatar_url text,
    role text DEFAULT 'mentor'::text,
    is_approved boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    mentor_id uuid,
    CONSTRAINT profiles_pkey PRIMARY KEY (id),
    CONSTRAINT profiles_role_check CHECK ((role = ANY (ARRAY['mentor'::text, 'admin'::text, 'super_admin'::text]))),
    CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE,
    CONSTRAINT profiles_mentor_id_fkey FOREIGN KEY (mentor_id) REFERENCES public.mentors(id) ON DELETE SET NULL
);

-- Reviews table
CREATE TABLE IF NOT EXISTS public.reviews (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    review character varying,
    CONSTRAINT reviews_pkey PRIMARY KEY (id)
);

-- ============================================
-- INDEXES
-- ============================================
CREATE INDEX IF NOT EXISTS idx_mentors_active ON public.mentors(is_active);
CREATE INDEX IF NOT EXISTS idx_mentors_created_at ON public.mentors(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_mentors_display_order ON public.mentors(display_order);
CREATE INDEX IF NOT EXISTS idx_profiles_mentor_id ON public.profiles(mentor_id);

-- ============================================
-- FUNCTIONS
-- ============================================

-- Legacy admin functions
CREATE OR REPLACE FUNCTION public.get_admin_by_email(email_input text, p_secret text)
RETURNS SETOF public.admins
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
begin
  if not exists (select 1 from public.app_config where key = 'API_SECRET' and value = p_secret) then
    raise exception 'Unauthorized';
  end if;
  return query select * from public.admins where email = email_input;
end;
$$;

CREATE OR REPLACE FUNCTION public.get_admin_by_reset_token(p_token text, p_secret text)
RETURNS SETOF public.admins
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
begin
  if not exists (select 1 from public.app_config where key = 'API_SECRET' and value = p_secret) then
    raise exception 'Unauthorized';
  end if;
  return query select * from public.admins 
  where reset_token = p_token 
  and reset_token_expires > now();
end;
$$;

CREATE OR REPLACE FUNCTION public.update_admin_password(p_id uuid, p_hash text, p_secret text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
begin
  if not exists (select 1 from public.app_config where key = 'API_SECRET' and value = p_secret) then
    raise exception 'Unauthorized';
  end if;
  update public.admins
  set password = p_hash,
      reset_token = null,
      reset_token_expires = null
  where id = p_id;
end;
$$;

CREATE OR REPLACE FUNCTION public.update_admin_reset_token(p_email text, p_token text, p_expires timestamp with time zone, p_secret text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
begin
  if not exists (select 1 from public.app_config where key = 'API_SECRET' and value = p_secret) then
    raise exception 'Unauthorized';
  end if;
  update public.admins
  set reset_token = p_token,
      reset_token_expires = p_expires
  where email = p_email;
end;
$$;

-- Updated at trigger function
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- Profile updated at trigger function
CREATE OR REPLACE FUNCTION public.handle_profiles_updated_at()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- Handle new user signup (production version - simple)
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.profiles (id, email, display_name, avatar_url)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.email),
    NEW.raw_user_meta_data->>'avatar_url'
  );
  RETURN NEW;
END;
$$;

-- Role check functions
CREATE OR REPLACE FUNCTION public.is_admin_or_super_admin()
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid() AND role IN ('admin', 'super_admin')
  );
END;
$$;

CREATE OR REPLACE FUNCTION public.is_super_admin()
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid() AND role = 'super_admin'
  );
END;
$$;

-- ============================================
-- TRIGGERS
-- ============================================
DROP TRIGGER IF EXISTS update_mentors_updated_at ON public.mentors;
CREATE TRIGGER update_mentors_updated_at
    BEFORE UPDATE ON public.mentors
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS on_profiles_updated ON public.profiles;
CREATE TRIGGER on_profiles_updated
    BEFORE UPDATE ON public.profiles
    FOR EACH ROW EXECUTE FUNCTION public.handle_profiles_updated_at();

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- ============================================
-- ROW LEVEL SECURITY
-- ============================================
ALTER TABLE public.admins ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.app_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.mentors ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;

-- Mentor policies
DROP POLICY IF EXISTS "Enable read access for all users" ON public.mentors;
CREATE POLICY "Enable read access for all users" ON public.mentors
    FOR SELECT USING (true);

DROP POLICY IF EXISTS "Enable insert access for all users" ON public.mentors;
CREATE POLICY "Enable insert access for all users" ON public.mentors
    FOR INSERT WITH CHECK (true);

DROP POLICY IF EXISTS "Enable update access for all users" ON public.mentors;
CREATE POLICY "Enable update access for all users" ON public.mentors
    FOR UPDATE USING (true);

DROP POLICY IF EXISTS "Enable delete access for all users" ON public.mentors;
CREATE POLICY "Enable delete access for all users" ON public.mentors
    FOR DELETE USING (true);

-- Reviews policies
DROP POLICY IF EXISTS "Enable read access for all users" ON public.reviews;
CREATE POLICY "Enable read access for all users" ON public.reviews
    FOR SELECT USING (true);

-- Profile policies
DROP POLICY IF EXISTS "Users can view own profile" ON public.profiles;
CREATE POLICY "Users can view own profile" ON public.profiles
    FOR SELECT USING (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile" ON public.profiles;
CREATE POLICY "Users can update own profile" ON public.profiles
    FOR UPDATE USING (auth.uid() = id);

DROP POLICY IF EXISTS "Admins can view all profiles" ON public.profiles;
CREATE POLICY "Admins can view all profiles" ON public.profiles
    FOR SELECT USING (public.is_admin_or_super_admin());

DROP POLICY IF EXISTS "Super admins can update all profiles" ON public.profiles;
CREATE POLICY "Super admins can update all profiles" ON public.profiles
    FOR UPDATE USING (public.is_super_admin());

-- ============================================
-- GRANTS
-- ============================================
GRANT USAGE ON SCHEMA public TO postgres, anon, authenticated, service_role;

GRANT ALL ON TABLE public.admins TO anon, authenticated, service_role;
GRANT ALL ON TABLE public.app_config TO anon, authenticated, service_role;
GRANT ALL ON TABLE public.mentors TO anon, authenticated, service_role;
GRANT ALL ON TABLE public.profiles TO anon, authenticated, service_role;
GRANT ALL ON TABLE public.reviews TO anon, authenticated, service_role;
GRANT ALL ON SEQUENCE public.reviews_id_seq TO anon, authenticated, service_role;

GRANT ALL ON FUNCTION public.get_admin_by_email(text, text) TO anon, authenticated, service_role;
GRANT ALL ON FUNCTION public.get_admin_by_reset_token(text, text) TO anon, authenticated, service_role;
GRANT ALL ON FUNCTION public.handle_new_user() TO anon, authenticated, service_role;
GRANT ALL ON FUNCTION public.handle_profiles_updated_at() TO anon, authenticated, service_role;
GRANT ALL ON FUNCTION public.is_admin_or_super_admin() TO anon, authenticated, service_role;
GRANT ALL ON FUNCTION public.is_super_admin() TO anon, authenticated, service_role;
GRANT ALL ON FUNCTION public.update_admin_password(uuid, text, text) TO anon, authenticated, service_role;
GRANT ALL ON FUNCTION public.update_admin_reset_token(text, text, timestamp with time zone, text) TO anon, authenticated, service_role;
GRANT ALL ON FUNCTION public.update_updated_at_column() TO anon, authenticated, service_role;

-- Default privileges
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO postgres, anon, authenticated, service_role;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO postgres, anon, authenticated, service_role;

